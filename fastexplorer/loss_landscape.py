# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_loss_landscape.ipynb (unless otherwise specified).

__all__ = ['get_loss_landscape']

# Cell
from fastai2.vision.all import *
from .representation import *
from .explorer import *

# Cell
clientEvents.SEND_LANDSCAPE = 'socket/socketReceiveLossLandscape'

# Cell
def _normalize_direction(direction, weights):
    '''
    Rescale the filters (weights in group) in 'direction' so that each
    filter has the same norm as its corresponding filter in 'weights'.
    '''
    for d,w in zip(direction, weights): d.mul_(w.norm()/(d.norm() + 1e-10))

def _get_random_direction(m):
    weights = [o.data for o in m.parameters()]
    direction = [torch.randn(o.shape) for o in weights]

    for d,w in zip(direction, weights):
        if d.dim() <= 1: d.fill_(0)
        else           : _normalize_direction(d, w)

    return direction

def _compute_landscape(learn, samples=30, size=1, final_size=100):
    m = learn.model
    dls = learn.dls
    weights = [o.data.clone() for o in m.parameters()]
    xdirection = _get_random_direction(m)
    ydirection = _get_random_direction(m)
    xcoords = torch.linspace(-size, size, samples)
    ycoords = torch.linspace(-size, size, samples)
    losses = -torch.ones(samples,samples)
    xmesh,ymesh = torch.meshgrid(xcoords, ycoords)
    shape = losses.shape
    losses,xmesh,ymesh = [o.contiguous().view(-1) for o in [losses,xmesh,ymesh]]
    xb,yb = dls.one_batch()

    for l,x,y in progress_bar(zip(losses,xmesh,ymesh), total=losses.size(0)):
        changes = [(dx*x + dy*y) for dx,dy in zip(xdirection,ydirection)]
        for p,w,c in zip(m.parameters(), weights, changes): p.data = w.add(c.to(w.device))
        with torch.no_grad():
            yb_ = m.eval()(xb)
            loss = learn.loss_func(yb_, yb)

        l.fill_(loss)

    losses,xmesh,ymesh = [o.view(*shape) for o in [losses,xmesh,ymesh]]
    landscape = (F.interpolate(losses[None,None], [final_size,final_size], mode='bilinear',
                               align_corners=False)[0,0]
                 if final_size > samples else losses)
    return landscape.numpy()

# Cell
@patch
async def get_loss_landscape(self:FastExplorer, websocket, payload=None):
    "Sends the loss landscape for the model."
    try:
        if 'loss_landscape' not in self.cache.keys():
            self.cache['loss_landscape'] = _compute_landscape(self.learn)

        landscape = self.cache['loss_landscape']
        percentile = np.percentile(landscape, 95)
        array_bytes = get_numpy_bytes(landscape, clientEvents.SEND_LANDSCAPE, xtra={'max_z': percentile})
        await websocket.send_bytes(array_bytes)
    except Exception as e:
        await websocket.send_json({'type': clientEvents.SEND_ERROR,
                                   'payload': {'msg': 'Error getting the loss landscape.'}})